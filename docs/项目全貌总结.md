# FastGPT 项目开发手册

## 1. 项目全貌

### 1.1 核心业务实体
*   **Team (团队)**: 系统的顶层租户。一切资源（App, Dataset）都归属于 Team。
*   **App (应用)**: 用户构建的 Chatbot 或 Agent。包含了 Prompt、工作流配置等。
*   **Dataset (知识库)**: 存储向量数据的地方，用于 RAG 检索。
*   **Collaborator (协作者)**: 这是一个核心概念。资源（App/Dataset）不仅可以由 Owner 管理，还可以邀请其他 Team Member 协作。

### 1.2 Monorepo 架构详解 (pnpm workspace)
核心逻辑只有这几块：

*   **`projects/app` **:
    *   这是 Next.js 全栈应用。包含了前端 UI (`src/web`) 和 后端 API (`src/pages/api`)。
    *   **开发重点**: 95% 的业务逻辑改动都在这里。
    *   **API 规范**: RESTful + Next.js API Routes。

*   **`packages/service` (后端核心库)**:
    *   **定位**: 可以在多个 project（如 app, sandbox, mcp_server）间复用的后端逻辑。
    *   **关键目录**:
        *   `support/permission`: 全系统的权限逻辑核心（我们重点重构了这里）。
        *   `core/app`, `core/dataset`: 核心业务的 CRUD 和 Schema 定义。
        *   `common/mongo`: 数据库连接封装。

*   **`packages/global` (全栈类型库)**:
    *   **定位**: 前后端共用的类型定义 (Type)、常量 (Constant)、工具函数 (Utils)。
    *   **注意**: 这里 **绝不** 包含 Node.js 专用的代码（如 fs, mongoose），因为它要被前端 import。

*   **`packages/web` (前端组件库)**:
    *   **定位**: UI 组件、Hooks、i18n 配置。

---

## 2. 权限系统深度解析 ( The "Brain" of FastGPT)

### 2.1 权限模型 (Bitwise Permission)
我们不存储 "Admin", "Editor" 字符串，而是使用 **位运算** 存储权限值。

*   **定义位置**: `packages/global/support/permission/constant.ts`
*   **核心逻辑**:
    *   `Manage (1)`: `0b001` (二进制)
    *   `Write (2)`: `0b010`
    *   `Read (4)`: `0b100`
*   **推导规则**:
    *   拥有 `Manage` 权限，自动拥有 `Write` 和 `Read` (代码中通常写作 `Manage | Write | Read`)。
    *   **Owner 特权**: `Owner` 的权限值是 `~0` (所有位都为 1)，无所不能。

### 2.2 资源权限表 (MongoResourcePermission)
所有的协作者权限都存储既一张表中：`resource_permissions`。

| 字段 | 说明 |
| :--- | :--- |
| `teamId` | 资源所属的团队 |
| `resourceType` | 资源类型 (`app` 或 `dataset`) |
| `resourceId` | 具体的 App ID 或 Dataset ID |
| `tmbId` | 协作者的 Team Member ID (注意不是 User ID) |
| `permission` | 上述的位运算数值 |

**查询逻辑**:
当你要查看 "App A" 的成员时，实际上是在查 `ResourcePermission` 表中 `resourceId=AppA` 的所有记录。

### 2.3 继承与覆盖 (Inheritance)
*   系统中存在 `InheritPermission` (权限继承) 的概念。
*   **场景**: 一个文件夹里的 App，默认继承文件夹的协作者权限。
*   **冲突处理**: 如果你在子资源中显式修改了某人的权限，系统会要求你 "断开继承" (Disable Inherit)，否则逻辑会混乱。

---

## 3. 核心数据流 (Data Flow)

以 "修改协作者" 为例，展示数据如何流转：

1.  **UI 发起**: `MemberModal` 组件组装好包含 `tmbId` 和 `permission` 的数组。
2.  **API 请求**: 调用 `POST /api/core/app/collaborator/update`。
3.  **Zod 校验 (Guard)**: 后端第一步使用 `UpdateAppCollaboratorBodySchema` 校验。
    *   **规范**: 我们现在要求 **所有** API 的 Query 和 Body 都必须在 `packages/global/openapi` 中定义 Zod Schema。
4.  **Controller (Service)**:
    *   `getResourceOwnedClbs`: 获取当前数据库里的旧名单。
    *   **Sync Logic (关键)**: 对比 (Diff) 新旧名单。
        *   不再名单里的 -> `deleteOne`
        *   新出现的 -> `updateOne (upsert)`
5.  **DB 落盘**: 修改 `ResourcePermission` 集合。

---

## 4. 团队最新开发规范

### 4.1 API 开发铁律
*   **Zod First**: 此前项目里有很多手写的类型校验，现在 **严禁** 手写。必须使用 `zod` 定义 Schema，然后通过 `z.infer` 导出 TypeScript 类型给前端用。
    *   **好处**: 前后端类型 100% 同步，且运行时校验自动完成。
*   **路径规范**:
    *   Schema 定义: `packages/global/openapi/core/{module}/collaborator.ts`
    *   API 实现: `projects/app/src/pages/api/core/{module}/collaborator/list.ts`

### 4.2 前端调用规范
*   **禁止 Request Body 随意透传**: 必须定义明确的 Interface。
*   **GET 请求处理**: 我们的前端 Request 封装 (`GET`) 目前只接受一个泛型参数（返回类型）。不要试图把 Query 类型传进去，TS 会报错。

### 4.3 目录结构洁癖
*   **业务分离**: 属于 Dataset 的逻辑不要写在 App 里。
*   **Common 包**: 如果一段逻辑（比如权限计算）被 App 和 Sandbox 同时用到，必须下沉到 `packages/service`，禁止跨项目引用。

---

## 5. 建议

1.  **通读 Schema**: 去看 `packages/service/support/permission/schema.ts` 和 `user/team/teamSchema.ts`，这是数据的根基。
2.  **熟悉 UI**: 在本地把 "邀请成员"、"修改权限"、"转移 Owner"、"文件夹权限继承" 这些功能点一遍。
3.  **看 Zod 文件**: 去 `packages/global/openapi` 看看 API 接口定义的标准答案。
